{"version":3,"file":"ozp-iwc-owf7-widget-adapter.min.js","sources":["app/js/shindig/util.js","app/js/shindig/json.js","app/js/shindig/rpc.js","app/js/adapter/owf7Participant.js","app/js/adapter/owf7ParticipantListener.js","app/js/main.js"],"names":["gadgets","util","parseUrlParams","query","l","document","location","href","queryIdx","indexOf","hashIdx","substr","join","split","unescapeEntity","match","value","String","fromCharCode","init","config","features","parameters","onLoadHandlers","escapeCodePoints",10,13,34,39,60,62,92,8232,8233,"register","getUrlParameters","pairs","unesc","window","decodeURIComponent","unescape","i","j","length","pos","argName","substring","replace","makeClosure","scope","callback","baseArgs","arguments","push","tmpArgs","slice","apply","makeEnum","values","v","obj","getFeatureParameters","feature","hasFeature","registerOnLoadHandler","runOnLoadHandlers","escape","input","opt_escapeObjects","escapeString","newObject","field","hasOwnProperty","str","ch","shouldEscape","out","charCodeAt","charAt","unescapeString","json","f","n","stringify","a","k","r","test","c","m","Math","floor","toString","isFinite","propertyIsEnumerable","Date","prototype","toJSON","this","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","\b","\t","\n","\f","\r","\"","\\","parse","text","eval","rpc","getRelayChannel","postMessage","ActiveXObject","navigator","product","setupChannel","relayChannel","onmessage","packet","process","data","addEventListener","attachEvent","NIX_GET_WRAPPER","NIX_HANDLE_MESSAGE","NIX_CREATE_CHANNEL","name","channel","token","authToken","nix_channels","vbscript","NIX_WRAPPER","execScript","e","getId","windowName","id","setupFrame","frameId","setup","frame","getElementById","FE_G2C_CHANNEL","args","wrapper","contentWindow","opener","encodeLegacyData","argsEscaped","encodeURIComponent","s","Array","t","Error","result","call","CALLBACK_NAME","services","DEFAULT_NAME","callNix","targetId","serviceName","from","rpcData","handler","GetAuthToken","CreateChannel","SendMessage","callIfpc","callFrameElement","callArgs","fe","frameElement","FE_C2G_CHANNEL","relay","getRelayUrl","src","queueOut","useLegacyProtocol","callId","concat","useMultiPartMessages","part","message","payloadLength","URL_LIMIT","numPackets","ceil","packetIdx","emitInvisibleIframe","shift","isInPopup","_childWindows","isMessageComplete","arr","total","_childWindowMessageId","_childWindowMessageQueue","target","iframe","iframePool","ifr","recyclable","readyState","parentNode","removeChild","splice","createElement","style","border","width","height","visibility","position","onload","setTimeout","body","appendChild","getTargetWin","sameDomain","parent","ii","childWindow","callSameDomain","fn","targetEl","receiveSameDomain","parentRelayUrl","relayUrl","param","params","search","parentParam","callbacks","rpctoken","ifpctok","messagesIn","callbackId","_getChildWindowMessage","msgId","q","requiredConfig","NonEmptyStringValidator","unregister","registerDefault","unregisterDefault","channelType","console","log","targetWin","targetDoc","setRelayUrl","url","opt_useLegacy","useMultiPartMessagesForIFPC","setAuthToken","receive","fragment","parseInt","payload","completed","ozpIwc","Owf7Participant","listener","client","guid","rpcId","instanceId","widgetQuery","widgetParams","webContextPath","preferenceLocation","prefsUrl","rpcRelay","layout","containerVersion","owf","lang","currentTheme","themeName","themeContrast","themeFontSize","version","locked","launchData","subscriptions","setAttribute","JSON","onContainerInit","sender","random","initMessage","idString","jsonString","onPublish","command","send","dst","resource","action","entity","onSubscribe","self","newValue","onUnsubscribe","absolutePath","link","protocol","host","pathname","hash","Owf7ParticipantListener","participants","rpcString","getParticipant","p","dest","addWidget","InternalParticipant","defaultRouter","registerParticipant","parseQueryParams","adapter"],"mappings":"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","sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nvar gadgets = gadgets || {};\n\n/**\n * @fileoverview General purpose utilities that gadgets can use.\n */\n\n/**\n * @static\n * @class Provides general-purpose utility functions.\n * @name gadgets.util\n */\n\ngadgets.util = function() {\n  /**\n   * Parses URL parameters into an object.\n   * @return {Array.&lt;String&gt;} The parameters\n   */\n  function parseUrlParams() {\n    // Get settings from url, 'hash' takes precedence over 'search' component\n    // don't use document.location.hash due to browser differences.\n    var query;\n    var l = document.location.href;\n    var queryIdx = l.indexOf(\"?\");\n    var hashIdx = l.indexOf(\"#\");\n    if (hashIdx === -1) {\n      query = l.substr(queryIdx + 1);\n    } else {\n      // essentially replaces \"#\" with \"&\"\n      query = [l.substr(queryIdx + 1, hashIdx - queryIdx - 1), \"&\",\n               l.substr(hashIdx + 1)].join(\"\");\n    }\n    return query.split(\"&\");\n  }\n\n  var parameters = null;\n  var features = {};\n  var onLoadHandlers = [];\n\n  // Maps code points to the value to replace them with.\n  // If the value is \"false\", the character is removed entirely, otherwise\n  // it will be replaced with an html entity.\n  var escapeCodePoints = {\n   // nul; most browsers truncate because they use c strings under the covers.\n   0 : false,\n   // new line\n   10 : true,\n   // carriage return\n   13 : true,\n   // double quote\n   34 : true,\n   // single quote\n   39 : true,\n   // less than\n   60 : true,\n   // greater than\n   62 : true,\n   // Backslash\n   92 : true,\n   // line separator\n   8232 : true,\n   // paragraph separator\n   8233 : true\n  };\n\n  /**\n   * Regular expression callback that returns strings from unicode code points.\n   *\n   * @param {Array} match Ignored\n   * @param {String} value The codepoint value to convert\n   * @return {String} The character corresponding to value.\n   */\n  function unescapeEntity(match, value) {\n    return String.fromCharCode(value);\n  }\n\n  /**\n   * Initializes feature parameters.\n   */\n  function init(config) {\n    features = config[\"core.util\"] || {};\n  }\n  if (gadgets.config) {\n    gadgets.config.register(\"core.util\", null, init);\n  }\n\n  return /** @scope gadgets.util */ {\n\n    /**\n     * Gets the URL parameters.\n     *\n     * @return {Object} Parameters passed into the query string\n     * @member gadgets.util\n     * @private Implementation detail.\n     */\n    getUrlParameters : function () {\n      if (parameters !== null) {\n        return parameters;\n      }\n      parameters = {};\n      var pairs = parseUrlParams();\n      var unesc = window.decodeURIComponent ? decodeURIComponent : unescape;\n      for (var i = 0, j = pairs.length; i < j; ++i) {\n        var pos = pairs[i].indexOf('=');\n        if (pos === -1) {\n          continue;\n        }\n        var argName = pairs[i].substring(0, pos);\n        var value = pairs[i].substring(pos + 1);\n        // difference to IG_Prefs, is that args doesn't replace spaces in\n        // argname. Unclear on if it should do:\n        // argname = argname.replace(/\\+/g, \" \");\n        value = value.replace(/\\+/g, \" \");\n        parameters[argName] = unesc(value);\n      }\n      return parameters;\n    },\n\n    /**\n     * Creates a closure that is suitable for passing as a callback.\n     * Any number of arguments\n     * may be passed to the callback;\n     * they will be received in the order they are passed in.\n     *\n     * @param {Object} scope The execution scope; may be null if there is no\n     *     need to associate a specific instance of an object with this\n     *     callback\n     * @param {Function} callback The callback to invoke when this is run;\n     *     any arguments passed in will be passed after your initial arguments\n     * @param {Object} var_args Initial arguments to be passed to the callback\n     *\n     * @member gadgets.util\n     * @private Implementation detail.\n     */\n    makeClosure : function (scope, callback, var_args) {\n      // arguments isn't a real array, so we copy it into one.\n      var baseArgs = [];\n      for (var i = 2, j = arguments.length; i < j; ++i) {\n       baseArgs.push(arguments[i]);\n      }\n      return function() {\n        // append new arguments.\n        var tmpArgs = baseArgs.slice();\n        for (var i = 0, j = arguments.length; i < j; ++i) {\n          tmpArgs.push(arguments[i]);\n        }\n        return callback.apply(scope, tmpArgs);\n      };\n    },\n\n    /**\n     * Utility function for generating an \"enum\" from an array.\n     *\n     * @param {Array.<String>} values The values to generate.\n     * @return {Map&lt;String,String&gt;} An object with member fields to handle\n     *   the enum.\n     *\n     * @private Implementation detail.\n     */\n    makeEnum : function (values) {\n      var obj = {};\n      for (var i = 0, v; v = values[i]; ++i) {\n        obj[v] = v;\n      }\n      return obj;\n    },\n\n    /**\n     * Gets the feature parameters.\n     *\n     * @param {String} feature The feature to get parameters for\n     * @return {Object} The parameters for the given feature, or null\n     *\n     * @member gadgets.util\n     */\n    getFeatureParameters : function (feature) {\n      return typeof features[feature] === \"undefined\"\n          ? null : features[feature];\n    },\n\n    /**\n     * Returns whether the current feature is supported.\n     *\n     * @param {String} feature The feature to test for\n     * @return {Boolean} True if the feature is supported\n     *\n     * @member gadgets.util\n     */\n    hasFeature : function (feature) {\n      return typeof features[feature] !== \"undefined\";\n    },\n\n    /**\n     * Registers an onload handler.\n     * @param {Function} callback The handler to run\n     *\n     * @member gadgets.util\n     */\n    registerOnLoadHandler : function (callback) {\n      onLoadHandlers.push(callback);\n    },\n\n    /**\n     * Runs all functions registered via registerOnLoadHandler.\n     * @private Only to be used by the container, not gadgets.\n     */\n    runOnLoadHandlers : function () {\n      for (var i = 0, j = onLoadHandlers.length; i < j; ++i) {\n        onLoadHandlers[i]();\n      }\n    },\n\n    /**\n     * Escapes the input using html entities to make it safer.\n     *\n     * If the input is a string, uses gadgets.util.escapeString.\n     * If it is an array, calls escape on each of the array elements\n     * if it is an object, will only escape all the mapped keys and values if\n     * the opt_escapeObjects flag is set. This operation involves creating an\n     * entirely new object so only set the flag when the input is a simple\n     * string to string map.\n     * Otherwise, does not attempt to modify the input.\n     *\n     * @param {Object} input The object to escape\n     * @param {Boolean} opt_escapeObjects Whether to escape objects.\n     * @return {Object} The escaped object\n     * @private Only to be used by the container, not gadgets.\n     */\n    escape : function(input, opt_escapeObjects) {\n      if (!input) {\n        return input;\n      } else if (typeof input === \"string\") {\n        return gadgets.util.escapeString(input);\n      } else if (typeof input === \"array\") {\n        for (var i = 0, j = input.length; i < j; ++i) {\n          input[i] = gadgets.util.escape(input[i]);\n        }\n      } else if (typeof input === \"object\" && opt_escapeObjects) {\n        var newObject = {};\n        for (var field in input) if (input.hasOwnProperty(field)) {\n          newObject[gadgets.util.escapeString(field)]\n              = gadgets.util.escape(input[field], true);\n        }\n        return newObject;\n      }\n      return input;\n    },\n\n    /**\n     * Escapes the input using html entities to make it safer.\n     *\n     * Currently not in the spec -- future proposals may change\n     * how this is handled.\n     *\n     * TODO: Parsing the string would probably be more accurate and faster than\n     * a bunch of regular expressions.\n     *\n     * @param {String} str The string to escape\n     * @return {String} The escaped string\n     */\n    escapeString : function(str) {\n      var out = [], ch, shouldEscape;\n      for (var i = 0, j = str.length; i < j; ++i) {\n        ch = str.charCodeAt(i);\n        shouldEscape = escapeCodePoints[ch];\n        if (shouldEscape === true) {\n          out.push(\"&#\", ch, \";\");\n        } else if (shouldEscape !== false) {\n          // undefined or null are OK.\n          out.push(str.charAt(i));\n        }\n      }\n      return out.join(\"\");\n    },\n\n    /**\n     * Reverses escapeString\n     *\n     * @param {String} str The string to unescape.\n     */\n    unescapeString : function(str) {\n      return str.replace(/&#([0-9]+);/g, unescapeEntity);\n    }\n  };\n}();\n// Initialize url parameters so that hash data is pulled in before it can be\n// altered by a click.\ngadgets.util.getUrlParameters();\n\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * @fileoverview\n * The global object gadgets.json contains two methods.\n *\n * gadgets.json.stringify(value) takes a JavaScript value and produces a JSON\n * text. The value must not be cyclical.\n *\n * gadgets.json.parse(text) takes a JSON text and produces a JavaScript value.\n * It will return false if there is an error.\n*/\n\nvar gadgets = gadgets || {};\n\n/**\n * @static\n * @class Provides operations for translating objects to and from JSON.\n * @name gadgets.json\n */\n\n/**\n * Port of the public domain JSON library by Douglas Crockford.\n * See: http://www.json.org/json2.js\n */\ngadgets.json = function () {\n\n  /**\n   * Formats integers to 2 digits.\n   * @param {Number} n\n   */\n  function f(n) {\n    return n < 10 ? '0' + n : n;\n  }\n\n  Date.prototype.toJSON = function () {\n    return [this.getUTCFullYear(), '-',\n           f(this.getUTCMonth() + 1), '-',\n           f(this.getUTCDate()), 'T',\n           f(this.getUTCHours()), ':',\n           f(this.getUTCMinutes()), ':',\n           f(this.getUTCSeconds()), 'Z'].join(\"\");\n  };\n\n  // table of character substitutions\n  var m = {\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"' : '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  };\n\n  /**\n   * Converts a json object into a string.\n   */\n  function stringify(value) {\n    var a,          // The array holding the partial texts.\n        i,          // The loop counter.\n        k,          // The member key.\n        l,          // Length.\n        r = /[\"\\\\\\x00-\\x1f\\x7f-\\x9f]/g,\n        v;          // The member value.\n\n    switch (typeof value) {\n    case 'string':\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe ones.\n      return r.test(value) ?\n          '\"' + value.replace(r, function (a) {\n            var c = m[a];\n            if (c) {\n              return c;\n            }\n            c = a.charCodeAt();\n            return '\\\\u00' + Math.floor(c / 16).toString(16) +\n                (c % 16).toString(16);\n            }) + '\"'\n          : '\"' + value + '\"';\n    case 'number':\n    // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n    case 'boolean':\n    case 'null':\n      return String(value);\n    case 'object':\n    // Due to a specification blunder in ECMAScript,\n    // typeof null is 'object', so watch out for that case.\n      if (!value) {\n        return 'null';\n      }\n      // toJSON check removed; re-implement when it doesn't break other libs.\n      a = [];\n      if (typeof value.length === 'number' &&\n          !(value.propertyIsEnumerable('length'))) {\n        // The object is an array. Stringify every element. Use null as a\n        // placeholder for non-JSON values.\n        l = value.length;\n        for (i = 0; i < l; i += 1) {\n          a.push(stringify(value[i]) || 'null');\n        }\n        // Join all of the elements together and wrap them in brackets.\n        return '[' + a.join(',') + ']';\n      }\n      // Otherwise, iterate through all of the keys in the object.\n      for (k in value) if (value.hasOwnProperty(k)) {\n        if (typeof k === 'string') {\n          v = stringify(value[k]);\n          if (v) {\n            a.push(stringify(k) + ':' + v);\n          }\n        }\n      }\n      // Join all of the member texts together and wrap them in braces.\n      return '{' + a.join(',') + '}';\n    }\n  }\n\n  return {\n    stringify: stringify,\n    parse: function (text) {\n// Parsing happens in three stages. In the first stage, we run the text against\n// regular expressions that look for non-JSON patterns. We are especially\n// concerned with '()' and 'new' because they can cause invocation, and '='\n// because it can cause mutation. But just to be safe, we want to reject all\n// unexpected forms.\n\n// We split the first stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace all backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n      if (/^[\\],:{}\\s]*$/.test(text.replace(/\\\\[\"\\\\\\/b-u]/g, '@').\n          replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']').\n          replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n        return eval('(' + text + ')');\n      }\n      // If the text is not JSON parseable, then return false.\n\n      return false;\n    }\n  };\n}();\n\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\n/**\n * @fileoverview Remote procedure call library for gadget-to-container,\n * container-to-gadget, and gadget-to-gadget (thru container) communication.\n */\n\nvar gadgets = gadgets || {};\n\n/**\n * @static\n * @class Provides operations for making rpc calls.\n * @name gadgets.rpc\n */\ngadgets.rpc = function() {\n  //alert(\"Initing gadgets.rpc\");\n  // General constants.\n  var CALLBACK_NAME = '__cb';\n  var DEFAULT_NAME = '';\n\n  // Consts for FrameElement.\n  var FE_G2C_CHANNEL = '__g2c_rpc';\n  var FE_C2G_CHANNEL = '__c2g_rpc';\n\n  // Consts for NIX. VBScript doesn't\n  // allow items to start with _ for some reason,\n  // so we need to make these names quite unique, as\n  // they will go into the global namespace.\n  var NIX_WRAPPER = 'GRPC____NIXVBS_wrapper';\n  var NIX_GET_WRAPPER = 'GRPC____NIXVBS_get_wrapper';\n  var NIX_HANDLE_MESSAGE = 'GRPC____NIXVBS_handle_message';\n  var NIX_CREATE_CHANNEL = 'GRPC____NIXVBS_create_channel';\n\n  // JavaScript reference to the NIX VBScript wrappers.\n  // Gadgets will have but a single channel under\n  // nix_channels['..'] while containers will have a channel\n  // per gadget stored under the gadget's ID.\n  var nix_channels = {};\n\n  var services = {};\n  var iframePool = [];\n  var relayUrl = {};\n  var useLegacyProtocol = {};\n  var authToken = {};\n  var callId = 0;\n  var callbacks = {};\n  var setup = {};\n  var sameDomain = {};\n  var params = {};\n\n  // Load the authentication token for speaking to the container\n  // from the gadget's parameters, or default to '0' if not found.\n  if (gadgets.util) {\n    params = gadgets.util.getUrlParameters();\n\t//alert(\"gadget params: \" + params);\n  }\n\n  authToken['..'] = params.rpctoken || params.ifpctok || 0;\n\n  //ifpc mods\n  var URL_LIMIT = 2000;\n  var messagesIn = {};\n  var useMultiPartMessages = {};\n  //ifpc mods\n\n\n  /*\n   * Return a short code representing the best available cross-domain\n   * message transport available to the browser.\n   *\n   * + For those browsers that support native messaging (various implementations\n   *   of the HTML5 postMessage method), use that. Officially defined at\n   *   http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html.\n   *\n   *   postMessage is a native implementation of XDC. A page registers that\n   *   it would like to receive messages by listening the the \"message\" event\n   *   on the window (document in DPM) object. In turn, another page can\n   *   raise that event by calling window.postMessage (document.postMessage\n   *   in DPM) with a string representing the message and a string\n   *   indicating on which domain the receiving page must be to receive\n   *   the message. The target page will then have its \"message\" event raised\n   *   if the domain matches and can, in turn, check the origin of the message\n   *   and process the data contained within.\n   *\n   *     wpm: postMessage on the window object.\n   *        - Internet Explorer 8+\n   *        - Safari (latest nightlies as of 26/6/2008)\n   *        - Firefox 3+\n   *        - Opera 9+\n   *\n   *     dpm: postMessage on the document object.\n   *        - Opera 8+\n   *\n   * + For Internet Explorer before version 8, the security model allows anyone\n   *   parent to set the value of the \"opener\" property on another window,\n   *   with only the receiving window able to read it.\n   *   This method is dubbed \"Native IE XDC\" (NIX).\n   *\n   *   This method works by placing a handler object in the \"opener\" property\n   *   of a gadget when the container sets up the authentication information\n   *   for that gadget (by calling setAuthToken(...)). At that point, a NIX\n   *   wrapper is created and placed into the gadget by calling\n   *   theframe.contentWindow.opener = wrapper. Note that as a result, NIX can\n   *   only be used by a container to call a particular gadget *after* that\n   *   gadget has called the container at least once via NIX.\n   *\n   *   The NIX wrappers in this RPC implementation are instances of a VBScript\n   *   class that is created when this implementation loads. The reason for\n   *   using a VBScript class stems from the fact that any object can be passed\n   *   into the opener property.\n   *   While this is a good thing, as it lets us pass functions and setup a true\n   *   bidirectional channel via callbacks, it opens a potential security hole\n   *   by which the other page can get ahold of the \"window\" or \"document\"\n   *   objects in the parent page and in turn wreak havok. This is due to the\n   *   fact that any JS object useful for establishing such a bidirectional\n   *   channel (such as a function) can be used to access a function\n   *   (eg. obj.toString, or a function itself) created in a specific context,\n   *   in particular the global context of the sender. Suppose container\n   *   domain C passes object obj to gadget on domain G. Then the gadget can\n   *   access C's global context using:\n   *   var parentWindow = (new obj.toString.constructor(\"return window;\"))();\n   *   Nulling out all of obj's properties doesn't fix this, since IE helpfully\n   *   restores them to their original values if you do something like:\n   *   delete obj.toString; delete obj.toString;\n   *   Thus, we wrap the necessary functions and information inside a VBScript\n   *   object. VBScript objects in IE, like DOM objects, are in fact COM\n   *   wrappers when used in JavaScript, so we can safely pass them around\n   *   without worrying about a breach of context while at the same time\n   *   allowing them to act as a pass-through mechanism for information\n   *   and function calls. The implementation details of this VBScript wrapper\n   *   can be found in the setupChannel() method below.\n   *\n   *     nix: Internet Explorer-specific window.opener trick.\n   *       - Internet Explorer 6\n   *       - Internet Explorer 7\n   *\n   * + For Gecko-based browsers, the security model allows a child to call a\n   *   function on the frameElement of the iframe, even if the child is in\n   *   a different domain. This method is dubbed \"frameElement\" (fe).\n   *\n   *   The ability to add and call such functions on the frameElement allows\n   *   a bidirectional channel to be setup via the adding of simple function\n   *   references on the frameElement object itself. In this implementation,\n   *   when the container sets up the authentication information for that gadget\n   *   (by calling setAuth(...)) it as well adds a special function on the\n   *   gadget's iframe. This function can then be used by the gadget to send\n   *   messages to the container. In turn, when the gadget tries to send a\n   *   message, it checks to see if this function has its own function stored\n   *   that can be used by the container to call the gadget. If not, the\n   *   function is created and subsequently used by the container.\n   *   Note that as a result, FE can only be used by a container to call a\n   *   particular gadget *after* that gadget has called the container at\n   *   least once via FE.\n   *\n   *     fe: Gecko-specific frameElement trick.\n   *        - Firefox 1+\n   *\n   * + For all others, we have a fallback mechanism known as \"ifpc\". IFPC\n   *   exploits the fact that while same-origin policy prohibits a frame from\n   *   accessing members on a window not in the same domain, that frame can,\n   *   however, navigate the window heirarchy (via parent). This is exploited by\n   *   having a page on domain A that wants to talk to domain B create an iframe\n   *   on domain B pointing to a special relay file and with a message encoded\n   *   after the hash (#). This relay, in turn, finds the page on domain B, and\n   *   can call a receipt function with the message given to it. The relay URL\n   *   used by each caller is set via the gadgets.rpc.setRelayUrl(..) and\n   *   *must* be called before the call method is used.\n   *\n   *     ifpc: Iframe-based method, utilizing a relay page, to send a message.\n   */\n  function getRelayChannel() {\n//    return 'ifpc';\n    return typeof window.postMessage === 'function' ? 'wpm' :\n           typeof window.postMessage === 'object' ? 'wpm':\n           typeof document.postMessage === 'function' ? 'dpm' :\n           window.ActiveXObject ? 'nix' :\n           navigator.product === 'Gecko' ? 'fe' :\n           'ifpc';\n  }\n\n  /**\n   * Conducts any initial global work necessary to setup the\n   * channel type chosen.\n   */\n  function setupChannel() {\n    // If the channel type is one of the native\n    // postMessage based ones, setup the handler to receive\n    // messages.\n    if (relayChannel === 'dpm' || relayChannel === 'wpm') {\n      var onmessage = function (packet) {\n        // TODO validate packet.domain for security reasons\n        process(gadgets.json.parse(packet.data));\n      }\n\n      if (typeof window.addEventListener != 'undefined') {\n        window.addEventListener('message', onmessage, false);\n      } else if (typeof window.attachEvent != 'undefined') {\n        window.attachEvent('onmessage', onmessage);\n      }\n\n    }\n\n    // If the channel type is NIX, we need to ensure the\n    // VBScript wrapper code is in the page and that the\n    // global Javascript handlers have been set.\n    if (relayChannel === 'nix') {\n\n       //alert('nix setup!');\n\n      // VBScript methods return a type of 'unknown' when\n      // checked via the typeof operator in IE. Fortunately\n      // for us, this only applies to COM objects, so we\n      // won't see this for a real Javascript object.\n      if (typeof window[NIX_GET_WRAPPER] !== 'unknown') {\n        window[NIX_HANDLE_MESSAGE] = function(data) {\n          process(gadgets.json.parse(data));\n        };\n\n        window[NIX_CREATE_CHANNEL] = function(name, channel, token) {\n          // Verify the authentication token of the gadget trying\n          // to create a channel for us.\n          if (authToken[name] == token) {\n            nix_channels[name] = channel;\n          }\n        };\n\n        // Inject the VBScript code needed.\n        var vbscript =\n          // We create a class to act as a wrapper for\n          // a Javascript call, to prevent a break in of\n          // the context.\n          'Class ' + NIX_WRAPPER + '\\n '\n\n          // An internal member for keeping track of the\n          // name of the document (container or gadget)\n          // for which this wrapper is intended. For\n          // those wrappers created by gadgets, this is not\n          // used (although it is set to \"..\")\n          + 'Private m_Intended\\n'\n\n          // Stores the auth token used to communicate with\n          // the gadget. The GetChannelCreator method returns\n          // an object that returns this auth token. Upon matching\n          // that with its own, the gadget uses the object\n          // to actually establish the communication channel.\n          + 'Private m_Auth\\n'\n\n          // Method for internally setting the value\n          // of the m_Intended property.\n          + 'Public Sub SetIntendedName(name)\\n '\n          + 'If isEmpty(m_Intended) Then\\n'\n          + 'm_Intended = name\\n'\n          + 'End If\\n'\n          + 'End Sub\\n'\n\n          // Method for internally setting the value of the m_Auth property.\n          + 'Public Sub SetAuth(auth)\\n '\n          + 'If isEmpty(m_Auth) Then\\n'\n          + 'm_Auth = auth\\n'\n          + 'End If\\n'\n          + 'End Sub\\n'\n\n          // A wrapper method which actually causes a\n          // message to be sent to the other context.\n          + 'Public Sub SendMessage(data)\\n '\n          + NIX_HANDLE_MESSAGE + '(data)\\n'\n          + 'End Sub\\n'\n\n          // Returns the auth token to the gadget, so it can\n          // confirm a match before initiating the connection\n          + 'Public Function GetAuthToken()\\n '\n          + 'GetAuthToken = m_Auth\\n'\n          + 'End Function\\n'\n\n          // Method for setting up the container->gadget\n          // channel. Not strictly needed in the gadget's\n          // wrapper, but no reason to get rid of it. Note here\n          // that we pass the intended name to the NIX_CREATE_CHANNEL\n          // method so that it can save the channel in the proper place\n          // *and* verify the channel via the authentication token passed\n          // here.\n          + 'Public Sub CreateChannel(channel, auth)\\n '\n          + 'Call ' + NIX_CREATE_CHANNEL + '(m_Intended, channel, auth)\\n'\n          + 'End Sub\\n'\n          + 'End Class\\n'\n\n          // Function to get a reference to the wrapper.\n          + 'Function ' + NIX_GET_WRAPPER + '(name, auth)\\n'\n          + 'Dim wrap\\n'\n          + 'Set wrap = New ' + NIX_WRAPPER + '\\n'\n          + 'wrap.SetIntendedName name\\n'\n          + 'wrap.SetAuth auth\\n'\n          + 'Set ' + NIX_GET_WRAPPER + ' = wrap\\n'\n          + 'End Function';\n\n        try {\n          //alert('execScript! '+vbscript);\n          window.execScript(vbscript, 'vbscript');\n        } catch (e) {\n\n          //alert('exception! back to ifpc');\n          // Fall through to IFPC.\n          relayChannel = 'ifpc';\n        }\n      }\n    }\n  }\n\n  //Store the parsed window.name configuration, if necessary\n  var config = null;\n\n  //Parse the window.name configuration and cache it.  Handle the case\n  //where containers use a JSON string in the window name and a plain string,\n//  function getConfig() {\n//    if (config == null) {\n//        config = {};\n//        if (window.name.charAt(0) != '{') {\n//            config.rpcId = window.name;\n//            config.kernel = true;\n//        } else {\n//            config = gadgets.json.parse(window.name);\n//            config.rpcId = config.id;\n//            return config;\n//        }\n//    } else {\n//        return config;\n//    }\n//  }\n\n  //Get the IFrame ID from the window.name property.  Handle three cases\n  //1. OWF Webtop, which assumes IFrame IDs are identical to window names\n  //2. OWF Kernel, which assumes that IFrame IDs are contianed in the window name as JSON as the id field\n  //3. Others, which use a plain string in the window name and assume the IFrame id is also this plain string\n//  function getId(windowName) {\n//    var conf = getConfig();\n//    if (conf.kernel)\n//        return conf.rpcId;\n//    else\n//        return windowName;\n//  }\n\n  function getId(windowName) {\n    if (windowName.charAt(0) != '{') {\n      return windowName\n    }\n    else {\n      var obj = gadgets.json.parse(windowName);\n      var id = obj.id;\n      return gadgets.json.stringify({id:obj.id});\n    }\n  }\n\n  // Pick the most efficient RPC relay mechanism\n  var relayChannel = getRelayChannel();\n  //alert('relaychannel is '+relayChannel);\n\n  // Conduct any setup necessary for the chosen channel.\n  setupChannel();\n\n  // Create the Default RPC handler.\n  services[DEFAULT_NAME] = function() {\n    //suppress this error - no one should ever try to use a service that wasn't registered using our api\n    //throw new Error('Unknown RPC service: ' + this.s);\n  };\n\n  // Create a Special RPC handler for callbacks.\n  services[CALLBACK_NAME] = function(callbackId, result) {\n    var callback = callbacks[callbackId];\n    if (callback) {\n      delete callbacks[callbackId];\n      callback(result);\n    }\n  };\n\n  /**\n   * Conducts any frame-specific work necessary to setup\n   * the channel type chosen. This method is called when\n   * the container page first registers the gadget in the\n   * RPC mechanism. Gadgets, in turn, will complete the setup\n   * of the channel once they send their first messages.\n   */\n  function setupFrame(frameId, token) {\n    if (setup[frameId]) {\n      return;\n    }\n\n    if (relayChannel === 'fe') {\n      try {\n        var frame = document.getElementById(frameId);\n        frame[FE_G2C_CHANNEL] = function(args) {\n          process(gadgets.json.parse(args));\n        };\n      } catch (e) {\n        // Something went wrong. System will fallback to\n        // IFPC.\n      }\n    }\n\n    if (relayChannel === 'nix') {\n      try {\n        var frame = document.getElementById(frameId);\n        var wrapper = window[NIX_GET_WRAPPER](frameId, token);\n        frame.contentWindow.opener = wrapper;\n      } catch (e) {\n        // Something went wrong. System will fallback to\n        // IFPC.\n        //alert('setupFrame Error!:'+e.message);\n\n      }\n    }\n\n    setup[frameId] = true;\n  }\n\n  /**\n   * Encodes arguments for the legacy IFPC wire format.\n   *\n   * @param {Object} args\n   * @return {String} the encoded args\n   */\n  function encodeLegacyData(args) {\n    var stringify = gadgets.json.stringify;\n    var argsEscaped = [];\n    for(var i = 0, j = args.length; i < j; ++i) {\n      argsEscaped.push(encodeURIComponent(stringify(args[i])));\n    }\n    return argsEscaped.join('&');\n  }\n\n  /**\n   * Helper function to process an RPC request\n   * @param {Object} rpc RPC request object\n   * @private\n   */\n    function process(rpc) {\n    //\n    // RPC object contents:\n    //   s: Service Name\n    //   f: From\n    //   c: The callback ID or 0 if none.\n    //   a: The arguments for this RPC call.\n    //   t: The authentication token.\n    //\n    if (rpc && typeof rpc.s === 'string' && typeof rpc.f === 'string' &&\n        rpc.a instanceof Array) {\n\n      //ensure id is compatible\n      rpc.f = getId(rpc.f);\n\n      // Validate auth token.\n      if (authToken[rpc.f]) {\n        // We allow type coercion here because all the url params are strings.\n        if (authToken[rpc.f] != rpc.t) {\n          throw new Error(\"Invalid auth token.\");\n        }\n      }\n\n      // If there is a callback for this service, attach a callback function\n      // to the rpc context object for asynchronous rpc services.\n      //\n      // Synchronous rpc request handlers should simply ignore it and return a\n      // value as usual.\n      // Asynchronous rpc request handlers, on the other hand, should pass its\n      // result to this callback function and not return a value on exit.\n      //\n      // For example, the following rpc handler passes the first parameter back\n      // to its rpc client with a one-second delay.\n      //\n      // function asyncRpcHandler(param) {\n      //   var me = this;\n      //   setTimeout(function() {\n      //     me.callback(param);\n      //   }, 1000);\n      // }\n      if (rpc.c) {\n        rpc.callback = function(result) {\n          gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);\n        };\n      }\n\n      // Call the requested RPC service.\n      var result = (services[rpc.s] ||\n                    services[DEFAULT_NAME]).apply(rpc, rpc.a);\n\n      // If the rpc request handler returns a value, immediately pass it back\n      // to the callback. Otherwise, do nothing, assuming that the rpc handler\n      // will make an asynchronous call later.\n      if (rpc.c && typeof result != 'undefined') {\n        gadgets.rpc.call(rpc.f, CALLBACK_NAME, null, rpc.c, result);\n      }\n    }\n  }\n\n  /**\n   * Attempts to conduct an RPC call to the specified\n   * target with the specified data via the NIX\n   * method. If this method fails, the system attempts again\n   * using the known default of IFPC.\n   *\n   * @param {String} targetId Module Id of the RPC service provider.\n   * @param {String} serviceName Name of the service to call.\n   * @param {String} from Module Id of the calling provider.\n   * @param {Object} rpcData The RPC data for this call.\n   */\n  function callNix(targetId, serviceName, from, rpcData) {\n    try {\n//       alert('try nix targetId='+targetId);\n//       alert('try nix from='+from);\n      if (from != '..') {\n//        alert('try nix1');\n        // Call from gadget to the container.\n        var handler = nix_channels['..'];\n\n//        alert('Nix handler='+handler);\n        //alert('GetAuthToken'+(\"GetAuthToken\" in window.opener));\n//        alert('window.opener='+window.opener);\n\n        // If the gadget has yet to retrieve a reference to\n        // the NIX handler, try to do so now. We don't do a\n        // typeof(window.opener.GetAuthToken) check here\n        // because it means accessing that field on the COM object, which,\n        // being an internal function reference, is not allowed.\n        // \"in\" works because it merely checks for the prescence of\n        // the key, rather than actually accessing the object's property.\n        // This is just a sanity check, not a validity check.\n        if (!handler && window.opener && \"GetAuthToken\" in window.opener) {\n//          alert('try nix - handler');\n          handler = window.opener;\n\n          // Create the channel to the parent/container.\n          // First verify that it knows our auth token to ensure it's not\n          // an impostor.\n          if (handler.GetAuthToken() == authToken['..']) {\n            // Auth match - pass it back along with our wrapper to finish.\n            // own wrapper and our authentication token for co-verification.\n            var token = authToken['..'];\n            handler.CreateChannel(window[NIX_GET_WRAPPER]('..', token),\n                                  token);\n            // Set channel handler\n            nix_channels['..'] = handler;\n            window.opener = null;\n          }\n        }\n\n        // If we have a handler, call it.\n        if (handler) {\n          //alert('sent nix');\n          handler.SendMessage(rpcData);\n          return;\n        }\n\n//        alert('Nix did not send3');\n      } else {\n        // Call from container to a gadget[targetId].\n//        alert('try nix2 - nix_channels[targetId]='+nix_channels[targetId]);\n\n        // If we have a handler, call it.\n        if (nix_channels[targetId]) {\n//          alert('sent nix');\n          nix_channels[targetId].SendMessage(rpcData);\n          return;\n        }\n\n//        alert('Nix did not send1');\n      }\n\n//      alert('Nix did not send2');\n\n    } catch (e) {\n//      alert('Nix Failed!:'+e);\n    }\n\n//    alert('fallback ifpc');\n\n    // If we have reached this point, something has failed\n    // with the NIX method, so we default to using\n    // IFPC for this call.\n    callIfpc(targetId, serviceName, from, rpcData);\n  }\n\n  /**\n   * Attempts to conduct an RPC call to the specified\n   * target with the specified data via the FrameElement\n   * method. If this method fails, the system attempts again\n   * using the known default of IFPC.\n   *\n   * @param {String} targetId Module Id of the RPC service provider.\n   * @param {String} serviceName Service name to call.\n   * @param {String} from Module Id of the calling provider.\n   * @param {Object} rpcData The RPC data for this call.\n   * @param {Array.<Object>} callArgs Original arguments to call()\n   */\n  function callFrameElement(targetId, serviceName, from, rpcData, callArgs) {\n    //alert('callFrameElement!');\n    try {\n      if (from != '..') {\n        // Call from gadget to the container.\n        var fe = window.frameElement;\n\n        if (typeof fe[FE_G2C_CHANNEL] === 'function') {\n          // Complete the setup of the FE channel if need be.\n          if (typeof fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] !== 'function') {\n            fe[FE_G2C_CHANNEL][FE_C2G_CHANNEL] = function(args) {\n              process(gadgets.json.parse(args));\n            };\n          }\n\n          // Conduct the RPC call.\n          fe[FE_G2C_CHANNEL](rpcData);\n          return;\n        }\n      } else {\n        // Call from container to gadget[targetId].\n        var frame = document.getElementById(targetId);\n\n        if (typeof frame[FE_G2C_CHANNEL] === 'function' &&\n            typeof frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL] === 'function') {\n\n          // Conduct the RPC call.\n          frame[FE_G2C_CHANNEL][FE_C2G_CHANNEL](rpcData);\n          return;\n        }\n      }\n    } catch (e) {\n    }\n\n    // If we have reached this point, something has failed\n    // with the FrameElement method, so we default to using\n    // IFPC for this call.\n    callIfpc(targetId, serviceName, from, rpcData, callArgs);\n  }\n\n  /**\n   * Conducts an RPC call to the specified\n   * target with the specified data via the IFPC\n   * method.\n   *\n   * @param {String} targetId Module Id of the RPC service provider.\n   * @param {String} serviceName Service name to call.\n   * @param {String} from Module Id of the calling provider.\n   * @param {Object} rpcData The RPC data for this call.\n   * @param {Array.<Object>} callArgs Original arguments to call()\n   */\n  function callIfpc(targetId, serviceName, from, rpcData, callArgs) {\n    //alert(\"CONTAINER IFPC params: \" + targetId + \" \" + serviceName + \" \" + from + \" \" + rpcData + \" \" + callArgs);\n    // Retrieve the relay file used by IFPC. Note that\n    // this must be set before the call, and so we conduct\n    // an extra check to ensure it is not blank.\n    var relay = gadgets.rpc.getRelayUrl(targetId);\n\n    if (!relay) {\n      throw new Error('No relay file assigned for IFPC');\n    }\n\n    // The RPC mechanism supports two formats for IFPC (legacy and current).\n    var src = null,\n        queueOut = [];\n    if (useLegacyProtocol[targetId]) {\n      // Format: #iframe_id&callId&num_packets&packet_num&block_of_data\n      src = [relay, '#', encodeLegacyData([from, callId, 1, 0,\n             encodeLegacyData([from, serviceName, '', '', from].concat(\n               callArgs))])].join('');\n      queueOut.push(src);\n    } else {\n\n      // Format: #targetId & sourceId@callId & packetNum & packetId & packetData\n      src = [relay, '#', encodeURIComponent(targetId), '&', from, '@', callId, '&'].join('');\n      if (!useMultiPartMessages[targetId]) {\n        // Format: #targetId & sourceId@callId & packetNum & packetId & packetData\n        queueOut.push([src, 1, '&', 0, '&', , encodeURIComponent(rpcData)].join(''));\n\n      }\n      else {\n        var message = encodeURIComponent(rpcData),\n            payloadLength = URL_LIMIT - src.length,\n            numPackets = Math.ceil(message.length / payloadLength),\n            packetIdx = 0,\n            part;\n        while (message.length > 0) {\n          part = message.substring(0, payloadLength);\n          message = message.substring(payloadLength);\n          queueOut.push([src, numPackets, '&', packetIdx, '&', part].join(''));\n          packetIdx += 1;\n        }\n\n      }\n\n    }\n\n    // Conduct the IFPC call by creating the Iframe with\n    // the relay URL and appended message.\n    do {\n      emitInvisibleIframe(queueOut.shift(),targetId);\n    } while (queueOut.length > 0);\n    return true;\n\n\n  }\n\n  //IE only: return true if a target iframe id is in a child popup window\n  function isInPopup(targetId) {\n    if (!targetId) {\n      return false;\n    }\n    if (targetId == \"..\") {\n      return false;\n    }\n    var frame = document.getElementById(targetId);\n    if (frame) {\n      return false;\n    }\n    if (typeof _childWindows === 'undefined') {\n      return false;\n    }\n    return true;\n  }\n\n  //IE only: Queue of messages for child windows\n  window._childWindowMessageQueue = [];\n  //IE only: Unique increasing ID for all messages put on the child window queue\n  window._childWindowMessageId = 0;\n  //IE only: Allow a child window to retrieve a message from the queue\n  window._getChildWindowMessage = function(msgId) {\n    var q = _childWindowMessageQueue;\n    for(var ii=0; ii < q.length; ii++) {\n      var m = q[ii];\n      if (m.id == msgId) {\n        return m;\n      }\n    }\n  }\n\n  function isMessageComplete(arr, total) {\n    for (var i = total - 1; i >= 0; --i) {\n      if (typeof arr[i] === 'undefined') {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Helper function to emit an invisible IFrame.\n   * @param {String} src SRC attribute of the IFrame to emit.\n   * @private\n   */\n  function emitInvisibleIframe(src, targetId) {\n    if (isInPopup(targetId)) {\n        //IE only:\n        //Queue the message for our child iframes, which will poll for them.\n        //We do this because in IE a parent window does not have access to the\n        //document of child popup windows, and hence cannot emit an iframe\n        //within them\n        var id = window._childWindowMessageId;\n        id++;\n        window._childWindowMessageQueue.push({id:id, target:targetId, src:src});\n        window._childWindowMessageId++;\n        if(window._childWindowMessageQueue.length > 20) {\n          window._childWindowMessageQueue.shift();\n        }\n        return;\n    }\n    var iframe;\n    // Recycle IFrames\n    for (var i = iframePool.length - 1; i >=0; --i) {\n      var ifr = iframePool[i];\n      try {\n        if (ifr && (ifr.recyclable || ifr.readyState === 'complete')) {\n          ifr.parentNode.removeChild(ifr);\n          if (window.ActiveXObject) {\n            // For MSIE, delete any iframes that are no longer being used. MSIE\n            // cannot reuse the IFRAME because a navigational click sound will\n            // be triggered when we set the SRC attribute.\n            // Other browsers scan the pool for a free iframe to reuse.\n            iframePool[i] = ifr = null;\n            iframePool.splice(i, 1);\n          } else {\n            ifr.recyclable = false;\n            iframe = ifr;\n            break;\n          }\n        }\n      } catch (e) {\n        // Ignore; IE7 throws an exception when trying to read readyState and\n        // readyState isn't set.\n      }\n    }\n    // Create IFrame if necessary\n    if (!iframe) {\n      iframe = document.createElement('iframe');\n      iframe.style.border = iframe.style.width = iframe.style.height = '0px';\n      iframe.style.visibility = 'hidden';\n      iframe.style.position = 'absolute';\n      iframe.onload = function() { this.recyclable = true; };\n      iframePool.push(iframe);\n    }\n    iframe.src = src;\n    setTimeout(function() { document.body.appendChild(iframe); }, 0);\n  }\n\n    //Find a target IFrame or window based off an RPC ID, allowing for\n    //the fact that child popup windows with IFrames might exist.\n    function getTargetWin(id) {\n      if (typeof id === \"undefined\" || id === \"..\") {\n          // Chrome 30 throws SecurityError when accessing opener property on window.parent\n          try {\n            //Check to see if we are an iframe in a child window, and if so use the opener\n            if(sameDomain[id] !== false && window.parent.opener) {\n                return window.parent.opener.parent;\n            }\n          }\n          catch(e) {}\n          //Normal case, we are an IFrame in a page\n          return window.parent;\n      }\n\n      //At this point we are a container looking for a child iframe\n\n      // Cast to a String to avoid an index lookup.\n      id = String(id);\n\n      var target = null;\n\n      // Try window.frames first\n      //apparently in FF using window.frames will return a bogus window object if the\n      //iframe was removed and re-added to the document so it's always better to just do\n      //a dom lookup\n//      target = window.frames[id];\n//      if (target) {\n//          return target;\n//      }\n\n      // Fall back to getElementById()\n      target = document.getElementById(id);\n      if (target && target.contentWindow) {\n        return target.contentWindow;\n      }\n\n      // At this point we have missed on searching for child iframes\n      // in the main browser window, so search popup windows\n      // This assumes the container is keeping a list of child\n      // windows in the global _childWindows array\n      if (typeof _childWindows !== 'undefined') {\n          for(var ii=0; ii<_childWindows.length;ii++) {\n              var childWindow = _childWindows[ii];\n              try {\n                  //In IE 8, this will throw an exception.\n                  if (childWindow.document) {\n                      target = childWindow.document.getElementById(id);\n                  }\n              } catch(e) {\n                  //BUG. Don't know how to support\n                  //direct WMP calls from parent to child popups\n                  //in IE 8.\n              }\n              if (target && target.contentWindow) {\n                return target.contentWindow;\n              }\n          }\n      }\n      return null;\n    }\n\n\n  /**\n   * Attempts to make an rpc by calling the target's receive method directly.\n   * This works when gadgets are rendered on the same domain as their container,\n   * a potentially useful optimization for trusted content which keeps\n   * RPC behind a consistent interface.\n   * @param {String} target Module id of the rpc service provider\n   * @param {String} from Module id of the caller (this)\n   * @param {String} callbackId Id of the call\n   * @param {String} rpcData JSON-encoded RPC payload\n   * @return\n   */\n  function callSameDomain(target, rpc) {\n    var fn;\n\n    if (sameDomain[target] !== false) {\n      // Seed with a negative, typed value to avoid\n      // hitting this code path repeatedly\n      var targetEl = getTargetWin(target);\n\n      try {\n        // If this succeeds, then same-domain policy applied\n//        sameDomain[target] = targetEl.gadgets.rpc.receiveSameDomain;\n        fn = targetEl.gadgets.rpc.receiveSameDomain;\n      } catch (e) {\n        // Usual case: different domains\n      }\n    }\n\n    if (typeof fn === 'function') {\n      // Call target's receive method\n      fn(rpc);\n      sameDomain[target] = true;\n      return true;\n    }\n    else\n        sameDomain[target] = false;\n\n    return false;\n  }\n\n  // gadgets.config might not be available, such as when serving container js.\n  if (gadgets.config) {\n    /**\n     * Initializes RPC from the provided configuration.\n     */\n    function init(config) {\n\t  //alert(\"CONTAINER Config: \" + config);\n      // Allow for wild card parent relay files as long as it's from a\n      // white listed domain. This is enforced by the rendering servlet.\n      if (config.rpc.parentRelayUrl.substring(0, 7) === 'http://') {\n        relayUrl['..'] = config.rpc.parentRelayUrl;\n      } else {\n        // It's a relative path, and we must append to the parent.\n        // We're relying on the server validating the parent parameter in this\n        // case. Because of this, parent may only be passed in the query, not\n        // the fragment.\n        var params = document.location.search.substring(0).split(\"&\");\n\t\t//alert(\"Init Config method - Setting Params: \" + params);\n        var parentParam = \"\";\n        for (var i = 0, param; param = params[i]; ++i) {\n          // Only the first parent can be validated.\n          if (param.indexOf(\"parent=\") === 0) {\n            parentParam = decodeURIComponent(param.substring(7));\n            break;\n          }\n        }\n        relayUrl['..'] = parentParam + config.rpc.parentRelayUrl;\n      }\n      useLegacyProtocol['..'] = !!config.rpc.useLegacyProtocol;\n    }\n\n    var requiredConfig = {\n      parentRelayUrl : gadgets.config.NonEmptyStringValidator\n    };\n    gadgets.config.register(\"rpc\", requiredConfig, init);\n  }\n\n  return /** @scope gadgets.rpc */ {\n    /**\n     * Registers an RPC service.\n     * @param {String} serviceName Service name to register.\n     * @param {Function} handler Service handler.\n     *\n     * @member gadgets.rpc\n     */\n    register: function(serviceName, handler) {\n\t//alert(\"CONTAINER REGISTER VARIABLES: \" + serviceName + \" -|- \" + handler);\n      if (serviceName == CALLBACK_NAME) {\n        throw new Error(\"Cannot overwrite callback service\");\n      }\n\n      if (serviceName == DEFAULT_NAME) {\n        throw new Error(\"Cannot overwrite default service:\"\n                        + \" use registerDefault\");\n      }\n\t  services[serviceName] = handler;\n    },\n\n    /**\n     * Unregisters an RPC service.\n     * @param {String} serviceName Service name to unregister.\n     *\n     * @member gadgets.rpc\n     */\n    unregister: function(serviceName) {\n      if (serviceName == CALLBACK_NAME) {\n        throw new Error(\"Cannot delete callback service\");\n      }\n\n      if (serviceName == DEFAULT_NAME) {\n        throw new Error(\"Cannot delete default service:\"\n                        + \" use unregisterDefault\");\n      }\n\n      delete services[serviceName];\n    },\n\n    /**\n     * Registers a default service handler to processes all unknown\n     * RPC calls which raise an exception by default.\n     * @param {Function} handler Service handler.\n     *\n     * @member gadgets.rpc\n     */\n    registerDefault: function(handler) {\n      services[''] = handler;\n    },\n\n    /**\n     * Unregisters the default service handler. Future unknown RPC\n     * calls will fail silently.\n     *\n     * @member gadgets.rpc\n     */\n    unregisterDefault: function() {\n      delete services[''];\n    },\n\n    /**\n     * Calls an RPC service.\n     * @param {String} targetId Module Id of the RPC service provider.\n     *                          Empty if calling the parent container.\n     * @param {String} serviceName Service name to call.\n     * @param {Function|null} callback Callback function (if any) to process\n     *                                 the return value of the RPC request.\n     * @param {*} var_args Parameters for the RPC request.\n     *\n     * @member gadgets.rpc\n     */\n    call: function(targetId, serviceName, callback, var_args) {\n      ++callId;\n\t  targetId = getId(targetId) || '..';\n      if (callback) {\n        callbacks[callId] = callback;\n      }\n\n      // Default to the container calling.\n      var from = '..';\n\n      if (targetId === '..') {\n//        from = window.name;\n        from = getId(window.name);\n      }\n\n      // Not used by legacy, create it anyway...\n      var rpc = {\n        s: serviceName,\n        f: from,\n        c: callback ? callId : 0,\n        a: Array.prototype.slice.call(arguments, 3),\n        t: authToken[targetId]\n      };\n\n      // If target is on the same domain, call method directly\n      if (callSameDomain(targetId, rpc)) {\n        return;\n      }\n\n      var rpcData = gadgets.json.stringify(rpc);\n\n      var channelType = relayChannel;\n\n      // If we are told to use the legacy format, then we must\n      // default to IFPC.\n      if (useLegacyProtocol[targetId]) {\n        channelType = 'ifpc';\n      }\n\n      console.log(\"Sending to widget on \" + channelType + \" at url \" + relayUrl[targetId] + \" with \" + (typeof rpcData)+ \"=\", rpcData);\n      //alert('channelType:'+channelType);\n      switch (channelType) {\n        case 'dpm': // use document.postMessage.\n          // Get the window from the document. Fixes a bug with postMessage\n          // calls on a target that had been removed then appended to the document object\n            var targetWin = getTargetWin(targetId);\n            var targetDoc = targetWin.document;\n\n          if (targetDoc != null)\n            try {\n              targetDoc.postMessage(rpcData);\n            } catch (e) {\n              callIfpc(targetId, serviceName, from, rpcData, rpc.a);\n            }\n          break;\n\n        case 'wpm': // use window.postMessage.\n          // Get the window from the document. Fixes a bug with postMessage\n          // calls on a target that had been removed then appended to the document object\n            var targetWin = getTargetWin(targetId);\n\n          if (targetWin != null) {\n            try {\n              targetWin.postMessage(rpcData, \"*\");//relayUrl[targetId]);\n            } catch (e) {\n              callIfpc(targetId, serviceName, from, rpcData, rpc.a);\n            }\n          }\n          break;\n\n        case 'nix': // use NIX.\n          //alert('callNix!');\n          callNix(targetId, serviceName, from, rpcData);\n          break;\n\n        case 'fe': // use FrameElement.\n          callFrameElement(targetId, serviceName, from, rpcData, rpc.a);\n          break;\n\n        default: // use 'ifpc' as a fallback mechanism.\n          callIfpc(targetId, serviceName, from, rpcData, rpc.a);\n          break;\n      }\n    },\n\n    /**\n     * Gets the relay URL of a target frame.\n     * @param {String} targetId Name of the target frame.\n     * @return {String|undefined} Relay URL of the target frame.\n     *\n     * @member gadgets.rpc\n     */\n    getRelayUrl: function(targetId) {\n      return relayUrl[targetId];\n    },\n\n    /**\n     * Sets the relay URL of a target frame.\n     * @param {String} targetId Name of the target frame.\n     * @param {String} url Full relay URL of the target frame.\n     * @param {Boolean} opt_useLegacy True if this relay needs the legacy IFPC\n     *     wire format.\n     *\n     * @member gadgets.rpc\n     */\n    setRelayUrl: function(targetId, url, opt_useLegacy, useMultiPartMessagesForIFPC) {\n      relayUrl[targetId] = url;\n      useLegacyProtocol[targetId] = !!opt_useLegacy;\n      useMultiPartMessages[targetId] = !!useMultiPartMessagesForIFPC;\n    },\n\n    /**\n     * Sets the auth token of a target frame.\n     * @param {String} targetId Name of the target frame.\n     * @param {String} token The authentication token to use for all\n     *     calls to or from this target id.\n     *\n     * @member gadgets.rpc\n     */\n    setAuthToken: function(targetId, token) {\n      authToken[targetId] = token;\n      setupFrame(targetId, token);\n    },\n\n    /**\n     * Gets the RPC relay mechanism.\n     * @return {String} RPC relay mechanism. See above for\n     *   a list of supported types.\n     *\n     * @member gadgets.rpc\n     */\n    getRelayChannel: function() {\n      return relayChannel;\n    },\n\n    /**\n     * Receives and processes an RPC request. (Not to be used directly.)\n     * @param {Array.<String>} fragment An RPC request fragment encoded as\n     *        an array. The first 4 elements are target id, source id & call id,\n     *        total packet number, packet id. The last element stores the actual\n     *        JSON-encoded and URI escaped packet data.\n     *\n     * @member gadgets.rpc\n     */\n    receive: function(fragment) {\n      if (fragment.length > 4) {\n//        // TODO parse fragment[1..3] to merge multi-fragment messages\n//        process(gadgets.json.parse(\n//            decodeURIComponent(fragment[fragment.length - 1])));\n\n        var from = fragment[1],   // in the form of \"<from>@<callid>\"\n            numPackets = parseInt(fragment[2], 10),\n            packetIdx = parseInt(fragment[3], 10),\n            payload = fragment[fragment.length - 1],\n            completed = numPackets === 1;\n\n        // if message is multi-part, store parts in the proper order\n        if (numPackets > 1) {\n          if (!messagesIn[from]) {\n            messagesIn[from] = [];\n          }\n          messagesIn[from][packetIdx] = payload;\n          // check if all parts have been sent\n          if (isMessageComplete(messagesIn[from], numPackets)) {\n            payload = messagesIn[from].join('');\n            delete messagesIn[from];\n            completed = true;\n          }\n        }\n\n        // complete message sent\n        if (completed) {\n          process(gadgets.json.parse(decodeURIComponent(payload)));\n        }\n      }\n    },\n\n    /**\n     * Receives and processes an RPC request sent via the same domain.\n     * (Not to be used directly). Converts the inbound rpc object's\n     * Array into a local Array to pass the process() Array test.\n     * @param {Object} rpc RPC object containing all request params\n     */\n    receiveSameDomain: function(rpc) {\n      // Pass through to local process method but converting to a local Array\n      rpc.a = Array.prototype.slice.call(rpc.a);\n\t  window.setTimeout(function() { process(rpc) }, 0);\n    }\n  };\n}();\n","/* \n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nozpIwc.Owf7Participant=function(config) {\n    config = config || {};\n    if(!config.listener) { throw \"Needs to have an OWF7ParticipantListener\";}\n    if(!config.client) {throw \"Needs an IWC Client\";}\n    if(!config.guid) { throw \"Must be assigned a guid for this widget\";}\n    if(!config.url) { throw \"Needs a url for the widget\"; }\n    if(!config.iframe) { throw \"Needs an iframe\";}\n    if(!config.rpcId) { throw \"Needs an rpcID\";}\n    if(!config.instanceId) { throw \"Needs an widget instance id\";}\n    \n    this.client=config.client;\n    this.listener=config.listener;\n    this.rpcId=config.rpcId;\n    this.instanceId=config.instanceId;\n    \n    // Do a lookup on these two at some point\n    this.widgetQuery=\"?lang=en_US&owf=true&themeName=a_default&themeContrast=standard&themeFontSize=12\";\n    \n    this.iframe=config.iframe;\n\t// these get turned into the iframes name attribute\n\t// Refer to js/eventing/container.js:272\n\tthis.widgetParams={\n\t\t\"id\": this.instanceId,\n\t\t\"webContextPath\":\"/owf\",\n\t\t\"preferenceLocation\": this.listener.prefsUrl,\n\t\t\"relayUrl\":  this.listener.rpcRelay, \n\t\t\"url\": config.url,\n\t\t\"guid\": config.guid,\n\t\t// fixed values\n\t\t\"layout\":\"desktop\",\n\t\t\"containerVersion\":\"7.0.1-GA\",\n\t\t\"owf\":true,\n\t\t\"lang\":\"en_US\",\n\t\t\"currentTheme\":{\n\t\t\t\"themeName\":\"a_default\",\n\t\t\t\"themeContrast\":\"standard\",\n\t\t\t\"themeFontSize\":12\n\t\t},\t\t\n\t\t\"version\":1,\n\t\t\"locked\":false,\n        \"data\": config.launchData\n\t};\n\tthis.subscriptions={};\n\tthis.iframe.setAttribute(\"name\",JSON.stringify(this.widgetParams));\n    this.iframe.setAttribute(\"src\",this.widgetParams.url+this.widgetQuery);\n    this.iframe.setAttribute(\"id\",this.rpcId);\n};\n\nozpIwc.Owf7Participant.prototype.onContainerInit=function(sender,message) {\n    // The container sends params, but the widget JS ignores them\n    if ((window.name === \"undefined\") || (window.name === \"\")) {\n        window.name = \"ContainerWindowName\" + Math.random();\n    }\n    var initMessage = gadgets.json.parse(message);\n    var useMultiPartMessagesForIFPC = initMessage.useMultiPartMessagesForIFPC;\n    var idString = this.rpcId;//null;\n//\t\tif (initMessage.id.charAt(0) !== '{') {\n//\t\t\t\tidString = initMessage.id;\n//\t\t}\n//\t\telse {\n//\t\t\t\tvar obj = gadgets.json.parse(initMessage.id);\n//\t\t\t\tvar id = obj.id;\n//\t\t\t\tidString = gadgets.json.stringify({id:obj.id});\n//\t\t}\n\n    gadgets.rpc.setRelayUrl(idString, initMessage.relayUrl, false, useMultiPartMessagesForIFPC);\n    gadgets.rpc.setAuthToken(idString, 0);\n    var jsonString = '{\\\"id\\\":\\\"' + window.name + '\\\"}';\n    gadgets.rpc.call(idString, 'after_container_init', null, window.name, jsonString);\n    console.log(\"Registered \",idString,\" with relayUrl \",initMessage.relayUrl);\n};\n    \nozpIwc.Owf7Participant.prototype.onPublish=function(command, channel, message, dest) {\n    console.log(\"Publishing \",message,\" to \", channel);\n    this.client.send({\n        \"dst\": \"data.api\",\n        \"resource\": \"/owf-legacy/eventing/\" + channel,\n        \"action\": \"set\",\n        \"entity\": message\n    });\n};\nozpIwc.Owf7Participant.prototype.onSubscribe=function(command, channel, message, dest) {\n    console.log(\"Subscribing to \", channel);\n    var self=this;\n    this.subscriptions[channel]=true;\n    this.client.send({\n        \"dst\": \"data.api\",\n        \"resource\": \"/owf-legacy/eventing/\" + channel,\n        \"action\": \"watch\"\n    },function(packet,unregister) {\n        if(self.subscriptions[channel]) { \n            console.log(\"Got subscription for \" +self.rpcId + \" on \"+ channel, packet.entity.newValue);\n            // from shindig/pubsub_router.js:77    \n            //gadgets.rpc.call(subscriber, 'pubsub', null, channel, sender, message);\n            gadgets.rpc.call(self.rpcId, 'pubsub', null, channel, null, JSON.stringify(packet.entity.newValue));\n        }else {\n            unregister();\n        };\n    });\n};\nozpIwc.Owf7Participant.prototype.onUnsubscribe=function(command, channel, message, dest) {\n    console.log(\"Unsubscribing from \", channel);\n    this.subscriptions[channel]=false;\n};","(function() {\n    var absolutePath = function(href) {\n        var link = document.createElement(\"a\");\n        link.href = href;\n        return (link.protocol+\"//\"+link.host+link.pathname+link.search+link.hash);\n    };\n    \n\nozpIwc.Owf7ParticipantListener=function(config) {\n\tconfig = config || {};\n//    if(!config.url) { throw \"Needs a url for the widget\"; }\n//    if(!config.iframe) { throw \"Needs an iframe\";}\n//    if(!config.client) {throw \"Needs an IWC Client\";}\n\n    this.rpcRelay=absolutePath(config.rpcRelay || \"rpc_relay.uncompressed.html\");\n\tthis.prefsUrl=absolutePath(config.prefsUrl || \"owf7prefs.html\");\n    this.participants={};\n    \n    if ((window.name === \"undefined\") || (window.name === \"\")) {\n        window.name = \"ContainerWindowName\" + Math.random();\n    }\n\t\n    var rpcString=function(rpc) {\n\t\treturn \"[service:\" + rpc.s + \",from:\" + rpc.f + \"]:\" + JSON.stringify(rpc.a);\n\t};\n\tconsole.log(\"Registering RPC hooks\");\n\tgadgets.rpc.registerDefault(function() {\n\t\tconsole.log(\"Unknown rpc \" + rpcString(this));\n\t});\n    \n\tvar self=this;\n    var getParticipant=function(id) {\n        var p=self.participants[id];\n        if(!p) {\n            throw \"Unknown participant\";\n        }\n        return p;\n    };\n\t/**\n\t * Called by the widget to connect to the container\n\t * @see js/eventing/Container.js:26 for the containerInit function that much of this is copied from\n\t * @see js/eventing/Container.js:104 for the actual rpc.register\n\t */\n\tgadgets.rpc.register('container_init',function(sender,message) {\n        console.log(\"Connecting from a new recipient: \"+ sender + \" with message: \",message);\n        getParticipant(this.f).onContainerInit(sender,message);\n\t});\n\t\n\n\n\t/**\n\t * @param {string} command - publish | subscribe | unsubscribe\n\t * @param {string} channel - the OWF7 channel\n\t * @param {string} message - the message being published\n\t * @param {string} dest - the ID of the recipient if this is point-to-point\n\t * @see js/eventing/Container.js:376\n\t * @see js-lib/shindig/pubsub.js\n\t * @see js-lib/shindig/pubsub_router.js\n\t */\n//    var subscriptions={};\n\tgadgets.rpc.register('pubsub',function(command, channel, message, dest) {\n        var p=getParticipant(this.f);\n        switch (command) {\n            case 'publish': \n                p.onPublish(command, channel, message, dest);\n                break;\n            case 'subscribe':\n                p.onSubscribe(command, channel, message, dest);\n                break;\n            case 'unsubscribe': break;\n                p.onUnsubscribe(command, channel, message, dest);\n                break;\n        }\n\t});\n//\tgadgets.rpc.register('_widget_iframe_ready',function() {\n//\t\t// @see js/components/keys/KeyEventing.js\n//\t});\n\t\n    /**\n     * _fake_mouse_move is needed for drag and drop.  The container code is at\n     * @see reference\\js\\dd\\WidgetDragAndDropContainer.js:52\n     */\n    gadgets.rpc.register('_fake_mouse_move',function() {\n\t\t// @see @see reference\\js\\dd\\WidgetDragAndDropContainer.js:52\n\t});\n\t/**\n\t * @see js\\state\\WidgetStateContainer.js:35\n\t */\n//\tgadgets.rpc.register('_WIDGET_STATE_CHANNEL_'+this.widgetParams.id,function() {\n//\t\t\n//\t});\n//\n//\t// Intents API\n//\t\n//\t// used for both handling and invoking intents\n//\t// @see js/intents/WidgetIntentsContainer.js:32 for reference\n//\tgadgets.rpc.register('_intents',function(senderId, intent, data, destIds) {\n//\t});\n//\t\n//\t// used by widgets to register an intent\n//\t// @see js/intents/WidgetIntentsContainer.js:85 for reference\n//\tgadgets.rpc.register('_intents_receive',function(intent, destWidgetId) {\n//\t});\n//\n// Launcher API\n// The handling of the rpc event is in WidgetLauncherContainer\n// @see js/launcher/WidgetLauncherContainer.js:22, 36\n// msg: {\n//    universalName: 'universal name of widget to launch',  //universalName or guid maybe identify the widget to be launched\n//    guid: 'guid of widget to launch',\n//    title: 'title to replace the widgets title' the title will only be changed if the widget is opened.\n//    titleRegex: optional regex used to replace the previous title with the new value of title\n//    launchOnlyIfClosed: true, //if true will only launch the widget if it is not already opened.\n//                                   //if it is opened then the widget will be restored\n//    data: dataString  //initial launch config data to be passed to a widget only if the widget is opened.  this must be a string\n// });\n//  The steps to launch a widget are defined in dashboard.launchWidgetInstance\n//  @see js/components/dashboard/Dashboard.js:427\n//  The \"iframe properties\" come from Dashboard.onBeforeWidgetLaunch\n//  @see js/components/dashboard/Dashboard.js:318\n//  @see js\\eventing\\Container.js:237 for getIframeProperties()\n// WidgetIframeComponent actually creates the iframe tag.\n// @see js\\components\\widget\\WidgetIframeComponent.js:15\n\tgadgets.rpc.register('_WIDGET_LAUNCHER_CHANNEL',function(sender, msg) {\n        // if guid, look up by guid\n        // otherwise, look up by universalName\n        var widgetResource=\"/applications/blah/blah\";\n        // ignore title, titleRegex, and launchOnlyIfClosed\n        var data=\"\";\n\t});\n//\n//\t// WidgetProxy readiness\n//\t// @see js/kernel/kernel-rpc-base.js:130\n//\tgadgets.rpc.register('_widgetReady',function(widgetId) {\n//\t});\n//\t// @see js/kernel/kernel-rpc-base.js:147\n//\tgadgets.rpc.register('_getWidgetReady',function(widgetId, srcWidgetId) {\n//\t});\n//\n//\t// OWF.log\n//\tgadgets.rpc.register('Ozone.log',function() {\n//\t});\n//\n//\t// Widget State functions\n\n//\tgadgets.rpc.register('after_container_init',function() {\n//\t});\n//\n//\tgadgets.rpc.register('_WIDGET_STATE_CHANNEL_' + instanceId,function() {\n//\t});\n\n\n};\n\nozpIwc.Owf7ParticipantListener.prototype.addWidget=function(config) {\n  // From the caller: config.url and config.iframe\n  config.listener=this;\n  config.client=new ozpIwc.InternalParticipant();\n  ozpIwc.defaultRouter.registerParticipant(config.client);\n  config.guid=\"eb5435cf-4021-4f2a-ba69-dde451d12551\"; // FIXME: generate\n  config.instanceId=\"666f46bf-d8da-27c4-b907-f4a3a9e58c75\"; // FIXME: generate\n  config.rpcId=gadgets.json.stringify({id:config.instanceId});\n  this.participants[config.rpcId]=new ozpIwc.Owf7Participant(config);\n};\n\n\n\n})();","var params=ozpIwc.util.parseQueryParams();\n\n\nvar adapter=new ozpIwc.Owf7ParticipantListener();\nadapter.addWidget({\n    \"url\": params.url,\n    \"iframe\": document.getElementById(\"widgetFrame\")\n});\n\nconsole.log(\"Adapter: \",adapter.participants);"]}